# -*- coding: utf-8 -*-
"""Examen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qZLHPMWUbqHSAjNF667redGWdTwu7tbh
"""

import numpy as np
import pandas as pd
import pymc as pm
import arviz as az
import matplotlib.pyplot as plt

az.style.use("arviz-darkgrid")

df = pd.read_csv("bike_daily.csv")

y_raw = df["rentals"].to_numpy()
temp = df["temp_c"].to_numpy()
hum = df["humidity"].to_numpy()
wind = df["wind_kph"].to_numpy()
holiday = df["is_holiday"].to_numpy().astype(float)

season = df["season"].astype("category")
season_d = pd.get_dummies(season, drop_first=True).astype(float)
season_cols = season_d.columns.tolist()

temp_m, temp_s = temp.mean(), temp.std()
hum_m, hum_s = hum.mean(), hum.std()
wind_m, wind_s = wind.mean(), wind.std()

temp_z = (temp - temp_m) / temp_s
hum_z = (hum - hum_m) / hum_s
wind_z = (wind - wind_m) / wind_s

y_m, y_s = y_raw.mean(), y_raw.std()
y_z = (y_raw - y_m) / y_s


X_base = np.column_stack([temp_z, hum_z, wind_z, holiday, season_d.to_numpy()])

print("1)")
cols_for_scatter = ["rentals", "temp_c", "humidity", "wind_kph", "is_holiday"]
pd.plotting.scatter_matrix(df[cols_for_scatter], figsize=(10, 10), diagonal="hist")
plt.suptitle("Pairwise scatterplots")
plt.show()

print("2)")
with pm.Model() as m_lin:
    alpha = pm.Normal("alpha", mu=0, sigma=1)
    beta = pm.Normal("beta", mu=0, sigma=1, shape=X_base.shape[1])
    sigma = pm.HalfNormal("sigma", sigma=1)
    mu = alpha + pm.math.dot(X_base, beta)
    pm.Normal("y", mu=mu, sigma=sigma, observed=y_z)
    idata_lin = pm.sample(draws=2000, tune=2000, chains=2, cores=1, target_accept=0.9, random_seed=123, return_inferencedata=True, progressbar=False)
    idata_lin = pm.compute_log_likelihood(idata_lin, model=m_lin)
    ppc_lin = pm.sample_posterior_predictive(idata_lin, model=m_lin, extend_inferencedata=True, random_seed=123, progressbar=False)

print(az.summary(idata_lin, var_names=["alpha", "beta", "sigma"]))

print("2)")
temp_z2 = temp_z**2
X_poly = np.column_stack([temp_z, temp_z2, hum_z, wind_z, holiday, season_d.to_numpy()])

with pm.Model() as m_poly:
    alpha = pm.Normal("alpha", mu=0, sigma=1)
    beta = pm.Normal("beta", mu=0, sigma=1, shape=X_poly.shape[1])
    sigma = pm.HalfNormal("sigma", sigma=1)
    mu = alpha + pm.math.dot(X_poly, beta)
    pm.Normal("y", mu=mu, sigma=sigma, observed=y_z)
    idata_poly = pm.sample(draws=2000, tune=2000, chains=2, cores=1, target_accept=0.9, random_seed=123, return_inferencedata=True, progressbar=False)
    idata_poly = pm.compute_log_likelihood(idata_poly, model=m_poly)
    ppc_poly = pm.sample_posterior_predictive(idata_poly, model=m_poly, extend_inferencedata=True, random_seed=123, progressbar=False)

print(az.summary(idata_poly, var_names=["alpha", "beta", "sigma"]))

print("3)")
names_lin = ["temp_z", "hum_z", "wind_z", "is_holiday"] + season_cols
b_lin = idata_lin.posterior["beta"].values.reshape(-1, X_base.shape[1])
mabs_lin = np.abs(b_lin.mean(axis=0))
rank_lin = np.argsort(-mabs_lin)
print(pd.DataFrame({"var": np.array(names_lin)[rank_lin], "abs_mean_beta": mabs_lin[rank_lin]}))

names_poly = ["temp_z", "temp_z2", "hum_z", "wind_z", "is_holiday"] + season_cols
b_poly = idata_poly.posterior["beta"].values.reshape(-1, X_poly.shape[1])
mabs_poly = np.abs(b_poly.mean(axis=0))
rank_poly = np.argsort(-mabs_poly)
print(pd.DataFrame({"var": np.array(names_poly)[rank_poly], "abs_mean_beta": mabs_poly[rank_poly]}))

print("4)")
waic_l = az.waic(idata_lin, scale="deviance")
waic_p = az.waic(idata_poly, scale="deviance")

cmp_waic = az.compare({"linear": idata_lin, "polynomial": idata_poly}, method="BB-pseudo-BMA", ic="waic", scale="deviance")
display(cmp_waic)
plt.figure()
az.plot_compare(cmp_waic)
plt.show()


Q = np.quantile(y_raw, 0.75)
y_bin = (y_raw > Q).astype(int)

with pm.Model() as m_log_lin:
    a = pm.Normal("a", 0, 1)
    b = pm.Normal("b", 0, 1, shape=X_base.shape[1])
    eta = a + pm.math.dot(X_base, b)
    p = pm.Deterministic("p", pm.math.sigmoid(eta))
    pm.Bernoulli("y", p=p, observed=y_bin)
    id_log_lin = pm.sample(
        draws=2000, tune=2000, chains=2, cores=1, target_accept=0.9,
        random_seed=123, return_inferencedata=True, progressbar=False
    )
    id_log_lin = pm.compute_log_likelihood(id_log_lin, model=m_log_lin)

with pm.Model() as m_log_poly:
    a = pm.Normal("a", 0, 1)
    b = pm.Normal("b", 0, 1, shape=X_poly.shape[1])
    eta = a + pm.math.dot(X_poly, b)
    p = pm.Deterministic("p", pm.math.sigmoid(eta))
    pm.Bernoulli("y", p=p, observed=y_bin)
    id_log_poly = pm.sample(
        draws=2000, tune=2000, chains=2, cores=1, target_accept=0.9,
        random_seed=123, return_inferencedata=True, progressbar=False
    )
    id_log_poly = pm.compute_log_likelihood(id_log_poly, model=m_log_poly)