# -*- coding: utf-8 -*-
"""Laborator13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FidsBR7oUVo8fgn-0gNz5KFch6tMfFNf
"""

!pip -q install pymc arviz pytensor

import numpy as np
import pymc as pm
import pandas as pd
import arviz as az
import matplotlib.pyplot as plt

az.style.use("arviz-darkgrid")

df = pd.read_csv("date.csv", sep=r"\s+", header=None, names=["x","y"])
x_1 = df["x"].to_numpy()
y_1 = df["y"].to_numpy()

#Ex1.1(a)
order = 5
x_1p = np.vstack([x_1**i for i in range(1, order + 1)])
x_1s = (x_1p - x_1p.mean(axis=1, keepdims=True)) / x_1p.std(axis=1, keepdims=True)
y_1s = (y_1 - y_1.mean()) / y_1.std()

with pm.Model() as model_p_5_sd10:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=10, shape=order)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_p_5_sd10 = pm.sample(2000, return_inferencedata=True)

x_new = np.linspace(x_1s[0].min(), x_1s[0].max(), 100)
α_p_post = idata_p_5_sd10.posterior["α"].mean(("chain", "draw")).values
β_p_post = idata_p_5_sd10.posterior["β"].mean(("chain", "draw")).values
idx = np.argsort(x_1s[0])
y_p_post = α_p_post + np.dot(β_p_post, x_1s)

plt.figure()
plt.plot(x_1s[0][idx], y_p_post[idx], "C2", label=f"model order {order}")
plt.scatter(x_1s[0], y_1s, c="C0", marker=".")
plt.legend()
plt.show()

#Ex1.1(b) sd=100
with pm.Model() as model_p_5_sd100:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=100, shape=order)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_p_5_sd100 = pm.sample(2000, return_inferencedata=True)

α_p_post = idata_p_5_sd100.posterior["α"].mean(("chain", "draw")).values
β_p_post = idata_p_5_sd100.posterior["β"].mean(("chain", "draw")).values
y_p_post = α_p_post + np.dot(β_p_post, x_1s)

plt.figure()
plt.plot(x_1s[0][idx], y_p_post[idx], "C2", label=f"model order {order}")
plt.scatter(x_1s[0], y_1s, c="C0", marker=".")
plt.legend()
plt.show()

#Ex1.1(b) sd=[10,0.1,0.1,0.1,0.1]
with pm.Model() as model_p_5_sdvec:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=np.array([10, 0.1, 0.1, 0.1, 0.1]), shape=order)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_p_5_sdvec = pm.sample(2000, return_inferencedata=True)

α_p_post = idata_p_5_sdvec.posterior["α"].mean(("chain", "draw")).values
β_p_post = idata_p_5_sdvec.posterior["β"].mean(("chain", "draw")).values
y_p_post = α_p_post + np.dot(β_p_post, x_1s)

plt.figure()
plt.plot(x_1s[0][idx], y_p_post[idx], "C2", label=f"model order {order}")
plt.scatter(x_1s[0], y_1s, c="C0", marker=".")
plt.legend()
plt.show()

#Ex1.2
rng = np.random.default_rng(42)
n = len(x_1)
ii = rng.choice(n, size=500, replace=True)
x_1_500 = x_1[ii]
y_1_500 = y_1[ii]

order = 5
x_1p = np.vstack([x_1_500**i for i in range(1, order + 1)])
x_1s = (x_1p - x_1p.mean(axis=1, keepdims=True)) / x_1p.std(axis=1, keepdims=True)
y_1s = (y_1_500 - y_1_500.mean()) / y_1_500.std()

with pm.Model() as model_p_5_500:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=10, shape=order)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_p_5_500 = pm.sample(2000, return_inferencedata=True)

x_new = np.linspace(x_1s[0].min(), x_1s[0].max(), 100)
α_p_post = idata_p_5_500.posterior["α"].mean(("chain", "draw")).values
β_p_post = idata_p_5_500.posterior["β"].mean(("chain", "draw")).values
idx = np.argsort(x_1s[0])
y_p_post = α_p_post + np.dot(β_p_post, x_1s)

plt.figure()
plt.plot(x_1s[0][idx], y_p_post[idx], "C2", label=f"model order {order}")
plt.scatter(x_1s[0], y_1s, c="C0", marker=".")
plt.legend()
plt.show()

#Ex1.3
x_1 = d[:, 0]
y_1 = d[:, 1]
y_1s = (y_1 - y_1.mean()) / y_1.std()

order = 1
x_1p = np.vstack([x_1**i for i in range(1, order + 1)])
x_1s1 = (x_1p - x_1p.mean(axis=1, keepdims=True)) / x_1p.std(axis=1, keepdims=True)

with pm.Model() as model_l:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=10)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + β * x_1s1[0]
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_l = pm.sample(2000, return_inferencedata=True)

order = 2
x_1p = np.vstack([x_1**i for i in range(1, order + 1)])
x_1s2 = (x_1p - x_1p.mean(axis=1, keepdims=True)) / x_1p.std(axis=1, keepdims=True)

with pm.Model() as model_q:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=10, shape=2)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s2)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_q = pm.sample(2000, return_inferencedata=True)

order = 3
x_1p = np.vstack([x_1**i for i in range(1, order + 1)])
x_1s3 = (x_1p - x_1p.mean(axis=1, keepdims=True)) / x_1p.std(axis=1, keepdims=True)

with pm.Model() as model_c:
    α = pm.Normal("α", mu=0, sigma=1)
    β = pm.Normal("β", mu=0, sigma=10, shape=3)
    ϵ = pm.HalfNormal("ϵ", 5)
    µ = α + pm.math.dot(β, x_1s3)
    y_pred = pm.Normal("y_pred", mu=µ, sigma=ϵ, observed=y_1s)
    idata_c = pm.sample(2000, return_inferencedata=True)

pm.compute_log_likelihood(idata_l, model=model_l)
pm.compute_log_likelihood(idata_q, model=model_q)
pm.compute_log_likelihood(idata_c, model=model_c)

waic_l = az.waic(idata_l, scale="deviance")
waic_q = az.waic(idata_q, scale="deviance")
waic_c = az.waic(idata_c, scale="deviance")

loo_l = az.loo(idata_l, scale="deviance")
loo_q = az.loo(idata_q, scale="deviance")
loo_c = az.loo(idata_c, scale="deviance")

print(waic_l)
print(waic_q)
print(waic_c)
print(loo_l)
print(loo_q)
print(loo_c)

cmp_waic = az.compare({"linear": idata_l, "quadratic": idata_q, "cubic": idata_c}, method="BB-pseudo-BMA", ic="waic", scale="deviance")
display(cmp_waic)
plt.figure()
az.plot_compare(cmp_waic)
plt.show()

cmp_loo = az.compare({"linear": idata_l, "quadratic": idata_q, "cubic": idata_c}, method="BB-pseudo-BMA", ic="loo", scale="deviance")
display(cmp_loo)
plt.figure()
az.plot_compare(cmp_loo)
plt.show()